
CREATE TABLE users (
    USER_ID INT PRIMARY KEY,
    USER_NAME VARCHAR(20) NOT NULL,
    USER_STATUS VARCHAR(20) NOT NULL
);

CREATE TABLE logins (
    USER_ID INT,
    LOGIN_TIMESTAMP DATETIME NOT NULL,
    SESSION_ID INT PRIMARY KEY,
    SESSION_SCORE INT,
    FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID)
);

-- Users Table
INSERT INTO USERS VALUES (1, 'Alice', 'Active');
INSERT INTO USERS VALUES (2, 'Bob', 'Inactive');
INSERT INTO USERS VALUES (3, 'Charlie', 'Active');
INSERT INTO USERS  VALUES (4, 'David', 'Active');
INSERT INTO USERS  VALUES (5, 'Eve', 'Inactive');
INSERT INTO USERS  VALUES (6, 'Frank', 'Active');
INSERT INTO USERS  VALUES (7, 'Grace', 'Inactive');
INSERT INTO USERS  VALUES (8, 'Heidi', 'Active');
INSERT INTO USERS VALUES (9, 'Ivan', 'Inactive');
INSERT INTO USERS VALUES (10, 'Judy', 'Active');

-- Logins Table 

INSERT INTO LOGINS  VALUES (1, '2023-07-15 09:30:00', 1001, 85);
INSERT INTO LOGINS VALUES (2, '2023-07-22 10:00:00', 1002, 90);
INSERT INTO LOGINS VALUES (3, '2023-08-10 11:15:00', 1003, 75);
INSERT INTO LOGINS VALUES (4, '2023-08-20 14:00:00', 1004, 88);
INSERT INTO LOGINS  VALUES (5, '2023-09-05 16:45:00', 1005, 82);

INSERT INTO LOGINS  VALUES (6, '2023-10-12 08:30:00', 1006, 77);
INSERT INTO LOGINS  VALUES (7, '2023-11-18 09:00:00', 1007, 81);
INSERT INTO LOGINS VALUES (8, '2023-12-01 10:30:00', 1008, 84);
INSERT INTO LOGINS  VALUES (9, '2023-12-15 13:15:00', 1009, 79);

INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (1, '2024-01-10 07:45:00', 1011, 86);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (2, '2024-01-25 09:30:00', 1012, 89);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (3, '2024-02-05 11:00:00', 1013, 78);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (4, '2024-03-01 14:30:00', 1014, 91);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (5, '2024-03-15 16:00:00', 1015, 83);

INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (6, '2024-04-12 08:00:00', 1016, 80);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (7, '2024-05-18 09:15:00', 1017, 82);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (8, '2024-05-28 10:45:00', 1018, 87);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (9, '2024-06-15 13:30:00', 1019, 76);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-25 15:00:00', 1010, 92);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-26 15:45:00', 1020, 93);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-27 15:00:00', 1021, 92);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-28 15:45:00', 1022, 93);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (1, '2024-01-10 07:45:00', 1101, 86);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (3, '2024-01-25 09:30:00', 1102, 89);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (5, '2024-01-15 11:00:00', 1103, 78);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (2, '2023-11-10 07:45:00', 1201, 82);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (4, '2023-11-25 09:30:00', 1202, 84);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (6, '2023-11-15 11:00:00', 1203, 80);

select * from users;
select * from logins;

--1) Management wants to see all the users that didnot login in the past 5 months - return username
-- lets consider 28 june as today
with t1 as
(select user_id from logins 
group by user_id 
having max(LOGIN_TIMESTAMP)< dateadd(month,-5,cast('2024-06-28' as date)))

select u.user_name from t1 left join users u on t1.user_id = u.user_id;

--2) For the business unit quarterly analysis , calculate how many users  and how many sessions were at each quarter 
-- order by quarter from newest to oldest
-- Return first day of quarter, user_cnt, session_cnt

select datepart(quarter,dateadd(month,-9,LOGIN_TIMESTAMP)) as Quarter, count(*) as session_cnt,count(distinct user_id) as user_cnt,
datetrunc(quarter,min(login_timestamp)) as first_quarter_date from logins
GROUP BY datepart(quarter,dateadd(month,-9,LOGIN_TIMESTAMP));

--3) Display user ids that log in january 2024 and not log in November 2023

select distinct USER_ID from logins
where LOGIN_TIMESTAMP BETWEEN '2024-01-01' and '2024-01-31'
and USER_ID not in (select USER_ID from logins where LOGIN_TIMESTAMP between '2023-11-01' and '2023-11-30')
ORDER BY USER_ID;

--4) % change in last quarter session count , take help from second query
-- Return first day of quarter, session_cnt, session_cnt_prev, session_percent_change
with cte as
(select DATETRUNC(quarter,min(login_timestamp)) as first_quarter_date, count(SESSION_ID) as session_cnt from logins
group by datepart(QUARTER,LOGIN_TIMESTAMP))
select *,lag(session_cnt,1,session_cnt) over(order by first_quarter_date) as session_cnt_prev,
(session_cnt-lag(session_cnt,1,session_cnt) over(order by first_quarter_date))*100.0/lag(session_cnt,1,session_cnt) over(order by first_quarter_date) as session_percent_change from cte
;

-- 5) Display the user that had the highest session score (max) for each day 
-- Return Date, username,score
with cte as
(select USER_ID, cast(LOGIN_TIMESTAMP as date) as login_date, sum(SESSION_SCORE) as max_score, 
row_number() over(PARTITION BY cast(LOGIN_TIMESTAMP as date) order by sum(SESSION_SCORE) desc) as rn
from logins
group by USER_ID, cast(LOGIN_TIMESTAMP as date))
select cte.login_date,u.USER_NAME,cte.max_score from cte
left join users u on cte.USER_ID = u.USER_ID
 ;

=======
CREATE TABLE users (
    USER_ID INT PRIMARY KEY,
    USER_NAME VARCHAR(20) NOT NULL,
    USER_STATUS VARCHAR(20) NOT NULL
);

CREATE TABLE logins (
    USER_ID INT,
    LOGIN_TIMESTAMP DATETIME NOT NULL,
    SESSION_ID INT PRIMARY KEY,
    SESSION_SCORE INT,
    FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID)
);

-- Users Table
INSERT INTO USERS VALUES (1, 'Alice', 'Active');
INSERT INTO USERS VALUES (2, 'Bob', 'Inactive');
INSERT INTO USERS VALUES (3, 'Charlie', 'Active');
INSERT INTO USERS  VALUES (4, 'David', 'Active');
INSERT INTO USERS  VALUES (5, 'Eve', 'Inactive');
INSERT INTO USERS  VALUES (6, 'Frank', 'Active');
INSERT INTO USERS  VALUES (7, 'Grace', 'Inactive');
INSERT INTO USERS  VALUES (8, 'Heidi', 'Active');
INSERT INTO USERS VALUES (9, 'Ivan', 'Inactive');
INSERT INTO USERS VALUES (10, 'Judy', 'Active');

-- Logins Table 

INSERT INTO LOGINS  VALUES (1, '2023-07-15 09:30:00', 1001, 85);
INSERT INTO LOGINS VALUES (2, '2023-07-22 10:00:00', 1002, 90);
INSERT INTO LOGINS VALUES (3, '2023-08-10 11:15:00', 1003, 75);
INSERT INTO LOGINS VALUES (4, '2023-08-20 14:00:00', 1004, 88);
INSERT INTO LOGINS  VALUES (5, '2023-09-05 16:45:00', 1005, 82);

INSERT INTO LOGINS  VALUES (6, '2023-10-12 08:30:00', 1006, 77);
INSERT INTO LOGINS  VALUES (7, '2023-11-18 09:00:00', 1007, 81);
INSERT INTO LOGINS VALUES (8, '2023-12-01 10:30:00', 1008, 84);
INSERT INTO LOGINS  VALUES (9, '2023-12-15 13:15:00', 1009, 79);

INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (1, '2024-01-10 07:45:00', 1011, 86);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (2, '2024-01-25 09:30:00', 1012, 89);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (3, '2024-02-05 11:00:00', 1013, 78);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (4, '2024-03-01 14:30:00', 1014, 91);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (5, '2024-03-15 16:00:00', 1015, 83);

INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (6, '2024-04-12 08:00:00', 1016, 80);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (7, '2024-05-18 09:15:00', 1017, 82);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (8, '2024-05-28 10:45:00', 1018, 87);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (9, '2024-06-15 13:30:00', 1019, 76);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-25 15:00:00', 1010, 92);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-26 15:45:00', 1020, 93);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-27 15:00:00', 1021, 92);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (10, '2024-06-28 15:45:00', 1022, 93);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (1, '2024-01-10 07:45:00', 1101, 86);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (3, '2024-01-25 09:30:00', 1102, 89);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (5, '2024-01-15 11:00:00', 1103, 78);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (2, '2023-11-10 07:45:00', 1201, 82);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (4, '2023-11-25 09:30:00', 1202, 84);
INSERT INTO LOGINS (USER_ID, LOGIN_TIMESTAMP, SESSION_ID, SESSION_SCORE) VALUES (6, '2023-11-15 11:00:00', 1203, 80);

select * from users;
select * from logins;

--1) Management wants to see all the users that didnot login in the past 5 months - return username
-- lets consider 28 june as today
with t1 as
(select user_id from logins 
group by user_id 
having max(LOGIN_TIMESTAMP)< dateadd(month,-5,cast('2024-06-28' as date)))

select u.user_name from t1 left join users u on t1.user_id = u.user_id;

--2) For the business unit quarterly analysis , calculate how many users  and how many sessions were at each quarter 
-- order by quarter from newest to oldest
-- Return first day of quarter, user_cnt, session_cnt

select datepart(quarter,dateadd(month,-9,LOGIN_TIMESTAMP)) as Quarter, count(*) as session_cnt,count(distinct user_id) as user_cnt,
datetrunc(quarter,min(login_timestamp)) as first_quarter_date from logins
GROUP BY datepart(quarter,dateadd(month,-9,LOGIN_TIMESTAMP));

--3) Display user ids that log in january 2024 and not log in November 2023

select distinct USER_ID from logins
where LOGIN_TIMESTAMP BETWEEN '2024-01-01' and '2024-01-31'
and USER_ID not in (select USER_ID from logins where LOGIN_TIMESTAMP between '2023-11-01' and '2023-11-30')
ORDER BY USER_ID;

--4) % change in last quarter session count , take help from second query
-- Return first day of quarter, session_cnt, session_cnt_prev, session_percent_change
with cte as
(select DATETRUNC(quarter,min(login_timestamp)) as first_quarter_date, count(SESSION_ID) as session_cnt from logins
group by datepart(QUARTER,LOGIN_TIMESTAMP))
select *,lag(session_cnt,1,session_cnt) over(order by first_quarter_date) as session_cnt_prev,
(session_cnt-lag(session_cnt,1,session_cnt) over(order by first_quarter_date))*100.0/lag(session_cnt,1,session_cnt) over(order by first_quarter_date) as session_percent_change from cte
;

-- 5) Display the user that had the highest session score (max) for each day 
-- Return Date, username,score
with cte as
(select USER_ID, cast(LOGIN_TIMESTAMP as date) as login_date, sum(SESSION_SCORE) as max_score, 
row_number() over(PARTITION BY cast(LOGIN_TIMESTAMP as date) order by sum(SESSION_SCORE) desc) as rn
from logins
group by USER_ID, cast(LOGIN_TIMESTAMP as date))
select cte.login_date,u.USER_NAME,cte.max_score from cte
left join users u on cte.USER_ID = u.USER_ID;
 
 
<<<<<<< HEAD
-- 6) To identify our best users - Return the users that had a session on every single day snce their first login 
-- make assumption if needed, return user id
-- Assuming that that today is 28 june'24, so user should have to login till today from first login date

select user_id, min(cast(login_timestamp as date)) as first_logins_date,
datediff(day,min(cast(login_timestamp as date)),cast('2024-06-28' as date))+1 as no_of_logins_req,
count(distinct LOGIN_TIMESTAMP) as no_of_login_days
from logins 
group by user_id 
having count(distinct LOGIN_TIMESTAMP) = datediff(day,min(cast(login_timestamp as date)),cast('2024-06-28' as date))+1
order by user_id;

-- 7) on what dates there were no login at all? return login_dates
with cte as
(select cast(min(login_timestamp) as date) as first_date, cast('2024-06-28' as date) as last_date
from logins
UNION ALL
select dateadd(day,1,first_date),last_date from cte
where first_date<last_date
)
select * from cte 
where first_date not in 
(select distinct cast(login_timestamp as date) from logins)
OPTION(maxrecursion 500)
